> import Ex3FunctionsTypes
> import Ex3FunctionsEmulator
> import Ex3FunctionsCodeGenerator

-----------------------------------------------------------
Test harness, assumes you have written your code generator in 
the module "Ex3FunctionsCodeGenerator", and it defines "transFunction".

test0, test1, test2 etc are input programs for your code generator.
To execute the code generated by your translator, type
   test test0 1000
where test0 is the test program you want to try, and 1000 is the 
argument for the "main" function.

To see the code type
   putCode (transProgram test0)
-----------------------------------------------------------

> test program input = 
>   let 
>     state = interpret (compile program) input
>     (dn, a7, mem, syms, cmp) = state
>
>     out = "Result returned from main: "
>                ++ ( show( getReg resultReg state ) ) ++ "\n" ++
>           "Registers D0-7: " ++ (show dn) ++ "\n" ++
>           "Register  A7  : " ++ (show a7) ++ "\n" ++
>           -- in Exercise 3 you don't need .comm so you don't need this
>           (if syms /= [] then 
>             "--------------------------\n" ++
>             " Variables                \n" ++
>             "--------------------------\n" ++
>             printSyms syms mem
>           else "")
>   in 
>     putStr out   


> compile program =
>   [Jsr "main",
>    Halt] ++
>   transProgram program

> transProgram [] = []
> transProgram (def:defs) = (transFunction def)++(transProgram defs)

> putCode [] = putStr "\n"
> putCode (i:is) = do putStr (show i ++"\n") ; (putCode is)

------------------------------------------------------------------

Now for the tests

Test0: main x = 300

> test0 = [Defun "main" "x" (Minus (Var "x")(Const 300))]

Test1: main x = 2 - (dec (1-x))

> test1 
>  = [Defun "dec" "x" (Minus (Var "x") (Const 1)),
>     Defun "main" "x" (Minus (Const 2) (Apply "dec" (Minus (Const 1)(Var "x"))))]
 
Test2: main x = dec x - 100

> test2 
>  = [Defun "dec" "x" (Minus (Var "x") (Const 1)),
>     Defun "main" "x" (Minus (Apply "dec" (Var "x")) (Const 100))]

Test3: deep calls, multiple per call (needs big stack, 32 is too small)

> t3_basea x = x-1
> t3_baseb x = x-100
> t3_f5 x = t3_basea x - t3_baseb x
> t3_f4 x = t3_basea x - t3_f5 x
> t3_f3 x = t3_f5 x - t3_f4 x
> t3_f2 x = t3_f4 x - t3_f3 x
> t3_f1 x = t3_f3 x - t3_f2 x
> t3_main x = t3_f1 x
> test3
>  = [Defun "basea" "x" (Minus (Var "x") (Const 1)),
>     Defun "baseb" "x" (Minus (Var "x") (Const 100)),
>     Defun "f5" "x" (Minus (Apply "basea" (Var "x")) (Apply "baseb" (Var "x"))),
>     Defun "f4" "x" (Minus (Apply "basea" (Var "x")) (Apply "f5" (Var "x"))),
>     Defun "f3" "x" (Minus (Apply "f5" (Var "x")) (Apply "f4" (Var "x"))),
>     Defun "f2" "x" (Minus (Apply "f4" (Var "x")) (Apply "f3" (Var "x"))),
>     Defun "f1" "x" (Minus (Apply "f3" (Var "x")) (Apply "f2" (Var "x"))),
>     Defun "main" "x" (Apply "f1" (Var "x"))]

> t4_main x = dec x - dec 1000 where dec x = x-1
> test4 
>  = [Defun "dec" "x" (Minus (Var "x") (Const 1)),
>     Defun "main" "x" (Minus (Apply "dec" (Var "x")) (Apply "dec" (Const 1000)))
>    ]